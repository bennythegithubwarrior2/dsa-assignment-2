import ballerina/http;
import ballerina/time;
import ballerina/log;
import ballerina/lang.array;

// Define the Course record type
type Course record {|    
    string courseCode;  
    string courseName;  
    int nqfLevel;       
    string year;       
|};

// Define the Programme record type
type Programme record {| 
    readonly string programmeCode;  
    int nqfLevel;                   
    string qualificationTitle;      
    string faculty;                 
    string department;              
    string registrationDate;        
    int duration;                   
    Course[][] coursesByYear;      
|};

// Array to store Programme records
Programme[] programmes = [];

// Utility function to build a common HTTP error response
function buildErrorResponse(int statusCode, string message) returns http:Response {
    http:Response res = new;
    res.statusCode = statusCode;
    res.setPayload({ "error": message });
    return res;
}

// HTTP service exposed at /programmes endpoint on port 9090
service /programmes on new http:Listener(9090) {

    // 1. Add a new programme
    resource function post .(http:Caller caller, http:Request req) returns error? {
        // Extract the JSON payload from the request
        json|error payload = req.getJsonPayload();
        if payload is error {
            // Send 400 Bad Request if JSON payload is invalid
            return caller->respond(buildErrorResponse(400, "Invalid JSON payload"));
        }

        // Convert JSON payload to Programme type
        Programme|error programme = payload.cloneWithType(Programme);
        if programme is error {
            // Send 400 Bad Request if programme data is invalid
            return caller->respond(buildErrorResponse(400, "Invalid programme data"));
        }

        // Check if a programme with the same code already exists
        foreach var existingProgramme in programmes {
            if existingProgramme.programmeCode == programme.programmeCode {
                // Send 409 Conflict if programme code is already used
                return caller->respond(buildErrorResponse(409, "Programme code already exists"));
            }
        }

        // Add the new programme to the array in a thread-safe manner
        lock {
            programmes.push(programme);
        }

        // Respond with 201 Created and return the new programme
        http:Response res = new;
        res.statusCode = 201;
        res.setPayload(programme);
        return caller->respond(res);
    }

    // 2. Retrieve a list of all programmes
    resource function get .(http:Caller caller, http:Request req) returns error? {
        // Return the list of all stored programmes
        return caller->respond(programmes);
    }

    // 3. Update an existing programme's information
    resource function put [string programmeCode](http:Caller caller, http:Request req) returns error? {
        log:printInfo("Received PUT request for programme code: " + programmeCode);

        // Check if the programme with the given code exists
        int programmeIndex = -1;
        foreach int i in 0 ..< programmes.length() {
            if programmes[i].programmeCode == programmeCode {
                programmeIndex = i;
                break;
            }
        }
        if programmeIndex == -1 {
            // Send 404 Not Found if the programme does not exist
            log:printInfo("Programme code not found: " + programmeCode);
            return caller->respond(buildErrorResponse(404, "Programme not found"));
        }

        // Extract and validate the JSON payload
        json|error payload = req.getJsonPayload();
        if payload is error {
            // Send 400 Bad Request if the payload is invalid
            log:printInfo("Invalid JSON payload for programme code: " + programmeCode);
            return caller->respond(buildErrorResponse(400, "Invalid JSON payload"));
        }

        // Convert JSON payload to Programme type
        Programme|error updatedProgramme = payload.cloneWithType(Programme);
        if updatedProgramme is error {
            // Send 400 Bad Request if programme data is invalid
            log:printInfo("Invalid programme data for programme code: " + programmeCode);
            return caller->respond(buildErrorResponse(400, "Invalid programme data"));
        }

        // Check if the programme code in the path matches the one in the payload
        if updatedProgramme.programmeCode != programmeCode {
            // Send 400 Bad Request if there is a programme code mismatch
            log:printInfo("Programme code mismatch: Path - " + programmeCode + ", Payload - " + updatedProgramme.programmeCode);
            return caller->respond(buildErrorResponse(400, "Programme code mismatch"));
        }

        // Update the existing programme in the array in a thread-safe manner
        lock {
            programmes[programmeIndex] = updatedProgramme;
        }

        // Respond with success message and updated programme
        json successResponse = { 
            "message": "Programme updated successfully", 
            "programme": <json> updatedProgramme 
        };
        log:printInfo("Programme updated successfully: " + programmeCode);
        return caller->respond(successResponse);
    }

    // 4. Retrieve the details of a specific programme by programme code
    resource function get [string programmeCode](http:Caller caller, http:Request req) returns error? {
        // Iterate over programmes to find the one with the given code
        foreach var programme in programmes {
            if programme.programmeCode == programmeCode {
                // Return the requested programme
                return caller->respond(programme);
            }
        }
        // Send 404 Not Found if the programme doesn't exist
        return caller->respond(buildErrorResponse(404, "Programme not found"));
    }

    // 5. Delete a programme's record by programme code
    resource function delete [string programmeCode](http:Caller caller, http:Request req) returns error? {
        // Check if the programme exists
        int programmeIndex = -1;
        foreach int i in 0 ..< programmes.length() {
            if programmes[i].programmeCode == programmeCode {
                programmeIndex = i;
                break;
            }
        }
        if programmeIndex == -1 {
            // Send 404 Not Found if the programme doesn't exist
            return caller->respond(buildErrorResponse(404, "Programme not found"));
        }

        // Remove the programme from the array in a thread-safe manner
        lock {
            programmes = array:filter(programmes, function(Programme p) returns boolean {
                return p.programmeCode != programmeCode;
            });
        }

        // Send 204 No Content after successful deletion
        http:Response res = new;
        res.statusCode = 204; // No Content
        return caller->respond(res);
    }


    // 7. Retrieve all the programmes that belong to the same faculty
    resource function get faculty/[string facultyName](http:Caller caller, http:Request req) returns error? {
        Programme[] facultyProgrammes = [];
        // Iterate over all programmes and filter by faculty name
        foreach var programme in programmes {
            if programme.faculty.toLowerAscii() == facultyName.toLowerAscii() {
                facultyProgrammes.push(programme);
            }
        }
        // Return the list of programmes in the requested faculty
        return caller->respond(facultyProgrammes);
    }
}
