import ballerina/grpc;
import ballerina/io;

// In-memory data stores
map<Product> products = {};
map<Order> orders = {};
map<User> users = {};
map<string[]> carts = {};

listener grpc:Listener ep = new (9090);

@grpc:Descriptor {value: SHOPPING_DESC}
service "OnlineShopping" on ep {
    // PlaceOrderForAllCartItems RPC implementation
    remote function PlaceOrderForAllCartItems(PlaceOrderForAllCartItemsRequest value) returns PlaceOrderForAllCartItemsResponse|error {
        // Implementation for placing an order for all items in the user's cart
        if carts.hasKey(value.user_id) {
            string[] cart = carts.get(value.user_id).clone();
            if cart.length() == 0 {
                return error("Cart is empty");
            }
            // Collect products for the order
            Product[] orderProducts = from var sku in cart
                                      let Product? productOpt = products.get(sku)
                                      where productOpt is Product
                                      select productOpt;
            // Generate new order ID
            string orderId = "ORDER" + (orders.keys().length() + 1).toString();
            orders[orderId] = {order_id: orderId, user_id: value.user_id, products: orderProducts, status: "placed"};
            _ = carts.remove(value.user_id);
            io:println("All cart items ordered: ", orderId);
            return {order_id: orderId, message: "All cart items ordered successfully"};
        } else {
            return error("Cart not found for user");
        }
    }

    // AddProduct RPC implementation
    remote function AddProduct(AddProductRequest value) returns AddProductResponse|error {
        // Retrieve user from users map
        User? user = users.get(value.user_id);
        if user is User {
            // Check if user has admin privileges
            if user.role != "admin" {
                return error("Unauthorized: Only admins can add products.");
            }
        } else {
            return error("User not found");
        }

        Product product = value.product;
        // Validate product price
        if product.price < 0.0 {
            return error("Invalid product price. Price must be non-negative.");
        }
        // Validate stock quantity
        if product.stock_quantity < 0 {
            return error("Invalid stock quantity. Quantity must be non-negative.");
        }
        // Check if product with the given SKU already exists
        if products.hasKey(product.sku) {
            return error("Product with the given SKU already exists.");
        }
        // Set product status based on stock quantity
        product.status = product.stock_quantity > 0 ? "available" : "out_of_stock";
        products[product.sku] = product;
        io:println("Product added: ", product);
        return {product_code: product.sku};
    }

    // UpdateProduct RPC implementation
    remote function UpdateProduct(UpdateProductRequest value) returns UpdateProductResponse|error {
        // Retrieve user from users map
        User? user = users.get(value.user_id);
        if user is User {
            // Check if user has admin privileges
            if user.role != "admin" {
                return error("Unauthorized: Only admins can update products.");
            }
        } else {
            return error("User not found");
        }

        // Check if product exists
        if products.hasKey(value.sku) {
            Product updatedProduct = value.updated_product;
            // Validate updated product price
            if updatedProduct.price < 0.0 {
                return error("Invalid product price. Price must be non-negative.");
            }
            // Validate updated stock quantity
            if updatedProduct.stock_quantity < 0 {
                return error("Invalid stock quantity. Quantity must be non-negative.");
            }
            // Set product status based on stock quantity
            updatedProduct.status = updatedProduct.stock_quantity > 0 ? "available" : "out_of_stock";
            products[value.sku] = updatedProduct;
            io:println("Product updated: ", updatedProduct);
            return {success: true};
        } else {
            return error("Product not found");
        }
    }

    // RemoveProduct RPC implementation
    remote function RemoveProduct(RemoveProductRequest value) returns RemoveProductResponse|error {
        // Retrieve user from users map
        User? user = users.get(value.user_id);
        if user is User {
            // Check if user has admin privileges
            if user.role != "admin" {
                return error("Unauthorized: Only admins can remove products.");
            }
        } else {
            return error("User not found");
        }

        // Check if product exists
        if products.hasKey(value.sku) {
            _ = products.remove(value.sku);
            io:println("Product removed: ", value.sku);
            // Collect remaining products
            Product[] remainingProducts = from var [_, product] in products.entries()
                                          select product;
            return {products: remainingProducts};
        } else {
            return error("Product not found");
        }
    }

    // ManageStock RPC implementation
    remote function ManageStock(ManageStockRequest value) returns ManageStockResponse|error {
        // Check if product exists
        if products.hasKey(value.sku) {
            Product product = products.get(value.sku);
            if product.stock_quantity < value.quantity_to_decrease {
                return error("Not enough stock available");
            }
            // Decrease stock quantity
            product.stock_quantity -= value.quantity_to_decrease;
            // Update product status
            product.status = product.stock_quantity > 0 ? "available" : "out_of_stock";
            products[value.sku] = product;
            io:println("Stock updated for product: ", product.sku, ". Remaining stock: ", product.stock_quantity);
            return {success: true, message: "Stock updated successfully", remaining_stock: product.stock_quantity};
        } else {
            return error("Product not found");
        }
    }

    // ListAllOrders RPC implementation
    remote function ListAllOrders(ListAllOrdersRequest value) returns ListAllOrdersResponse|error {
        // Collect all orders
        Order[] allOrders = from var [_, orderValue] in orders.entries()
                            select orderValue;
        return {orders: allOrders};
    }

    // UpdateOrderStatus RPC implementation
    remote function UpdateOrderStatus(UpdateOrderStatusRequest value) returns UpdateOrderStatusResponse|error {
        // Retrieve user from users map
        User? user = users.get(value.user_id);
        if user is User {
            // Check if user has admin privileges
            if user.role != "admin" {
                return error("Unauthorized: Only admins can update order status.");
            }
        } else {
            return error("User not found");
        }

        // Check if order exists
        if orders.hasKey(value.order_id) {
            Order orderValue = orders.get(value.order_id);
            orderValue.status = value.status;
            orders[value.order_id] = orderValue;
            io:println("Order status updated: ", value.order_id, " -> ", value.status);
            return {success: true, message: "Order status updated successfully"};
        } else {
            return error("Order not found");
        }
    }

    // ListAvailableProducts RPC implementation
    remote function ListAvailableProducts(ListAvailableProductsRequest value) returns ListAvailableProductsResponse|error {
        // Collect available products
        Product[] availableProducts = from var [_, product] in products.entries()
                                      where product.status == "available"
                                      select product;
        return {products: availableProducts};
    }

    // SearchProduct RPC implementation
    remote function SearchProduct(SearchProductRequest value) returns SearchProductResponse|error {
        // Retrieve product by SKU
        Product? productOpt = products.get(value.sku);
        if productOpt is Product {
            return {product: productOpt, message: "Product found"};
        } else {
            return {message: "Product not available"};
        }
    }

    // AddToCart RPC implementation
    remote function AddToCart(AddToCartRequest value) returns AddToCartResponse|error {
        // Check if product exists
        if products.hasKey(value.sku) {
            // Retrieve or initialize the user's cart
            string[] cart = carts.hasKey(value.user_id) ? carts.get(value.user_id).clone() : [];
            cart.push(value.sku);
            carts[value.user_id] = cart;
            io:println("Added to cart: ", value.sku, " for user: ", value.user_id);
            return {success: true, message: "Product added to cart"};
        } else {
            return error("Product not found");
        }
    }

    // RemoveFromCart RPC implementation
    remote function RemoveFromCart(RemoveFromCartRequest value) returns RemoveFromCartResponse|error {
        // Check if cart exists for the user
        if carts.hasKey(value.user_id) {
            string[] cart = carts.get(value.user_id).clone();
            int? index = cart.indexOf(value.sku);
            if index is int {
                _ = cart.remove(index);
                carts[value.user_id] = cart;
                io:println("Removed from cart: ", value.sku, " for user: ", value.user_id);
                return {success: true, message: "Product removed from cart"};
            } else {
                return error("Product not found in cart");
            }
        } else {
            return error("Cart not found for user");
        }
    }

    // PlaceOrder RPC implementation
    remote function PlaceOrder(PlaceOrderRequest value) returns PlaceOrderResponse|error {
        // Check if cart exists for the user
        if carts.hasKey(value.user_id) {
            string[] cart = carts.get(value.user_id).clone();
            if cart.length() == 0 {
                return error("Cart is empty");
            }
            // Collect products for the order
            Product[] orderProducts = from var sku in cart
                                      let Product? productOpt = products.get(sku)
                                      where productOpt is Product
                                      select productOpt;
            // Generate new order ID
            string orderId = "ORDER" + (orders.keys().length() + 1).toString();
            orders[orderId] = {order_id: orderId, user_id: value.user_id, products: orderProducts, status: "placed"};
            _ = carts.remove(value.user_id);
            io:println("Order placed: ", orderId);
            return {order_id: orderId, message: "Order placed successfully"};
        } else {
            return error("Cart not found for user");
        }
    }

    // CreateUsers RPC implementation
    remote function CreateUsers(stream<CreateUserRequest, grpc:Error?> clientStream) returns CreateUsersResponse|error {
        while true {
            var result = clientStream.next();
            if result is record {| CreateUserRequest value; |} {
                User user = result.value.user;
                // Check if user already exists
                if users.hasKey(user.user_id) {
                    return error("User with the given ID already exists.");
                }
                users[user.user_id] = user;
                carts[user.user_id] = []; // Initialize an empty cart for the user
                io:println("User created: ", user);
            } else if result is grpc:Error {
                return result;
            } else {
                break;
            }
        }
        return {success: true};
    }

    // ListUsers RPC implementation
    remote function ListUsers(ListUsersRequest value) returns ListUsersResponse|error {
        // Collect all users
        User[] allUsers = from var [_, userValue] in users.entries()
                          select userValue;
        return {users: allUsers};
    }
}
