import ballerina/http;
import ballerina/log;

---------------------sample sql code-------------------------

public function main() returns error? {
    mysql:Client mysql = check new (host, user, password, database, port);
    stream<ProductRecieved, error?> streamOutput = mysql->query(
        `SELECT name, unitType, currencyISO, productId FROM products WHERE processed = false`);
    ProductRecieved[] productsRecieved = check from ProductRecieved items in streamOutput
        select items;
    foreach ProductRecieved prductRecieved in productsRecieved {
        Product product = {
            Name: prductRecieved.name,
            Product_Unit__c: prductRecieved.unitType,
            CurrencyIsoCode: prductRecieved.currencyISO
        };
        _ = check salesforce->create("Product2", product);
        _ = check mysql->execute(
            `UPDATE products SET processed = true WHERE productId = ${prductRecieved.productId}`);
    }

const int EXPRESS_TIME_CONFIRM = 10;
const int DISTANCE_CONFIRM = 100;
const int STANDARD_TIME_CONFIRM = 20;

type ShipmentRequest record {
    string shipmentType;
    int pickupLocation;
    int deliveryLocation;
    int preferredTime;
    string firstName;
    string lastName;
    string contactNumber;
};

// Define the function outside the service to ensure it's recognized
function determineServiceType(ShipmentRequest request) returns string {
    log:printInfo("Determining service type for request: " + request.toString());
    if (request.pickupLocation > DISTANCE_CONFIRM) {
        log:printInfo("Service type determined: International");
        return "International";
    } else if (request.preferredTime > EXPRESS_TIME_CONFIRM) {
        log:printInfo("Service type determined: Standard");
        return "Standard";
    } else if (request.preferredTime < STANDARD_TIME_CONFIRM) {
        log:printInfo("Service type determined: Express");
        return "Express";
    } else {
        log:printInfo("Service type determined: Unknown");
        return "Unknown";
    }
}

service /logistics on new http:Listener(9090) {

    resource function post determineService(http:Caller caller, http:Request req) returns error? {
        json payload = check req.getJsonPayload();
        ShipmentRequest shipmentRequest = check payload.cloneWithType(ShipmentRequest);

        string serviceType = determineServiceType(shipmentRequest);
        json response = { "serviceType": serviceType, "message": "Service determined successfully" };
        check caller->respond(response);
    }
}


----------------mario sample-----------------------

// Array to store Programme records
Programme[] programmes = [];

 // Add the new programme to the array in a thread-safe manner
        lock {
            programmes.push(programme);
        }


 // 2. Retrieve a list of all programmes
    resource function get .(http:Caller caller, http:Request req) returns error? {
        // Return the list of all stored programmes
        return caller->respond(programmes);
    }

    // 3. Update an existing programme's information
    resource function put [string programmeCode](http:Caller caller, http:Request req) returns error? {
        log:printInfo("Received PUT request for programme code: " + programmeCode);

        // Check if the programme with the given code exists
        int programmeIndex = -1;
        foreach int i in 0 ..< programmes.length() {
            if programmes[i].programmeCode == programmeCode {
                programmeIndex = i;
                break;
            }
        }
        if programmeIndex == -1 {
            // Send 404 Not Found if the programme does not exist
            log:printInfo("Programme code not found: " + programmeCode);
            return caller->respond(buildErrorResponse(404, "Programme not found"));
        }

        // Extract and validate the JSON payload
        json|error payload = req.getJsonPayload();
        if payload is error {
            // Send 400 Bad Request if the payload is invalid
            log:printInfo("Invalid JSON payload for programme code: " + programmeCode);
            return caller->respond(buildErrorResponse(400, "Invalid JSON payload"));
        }

        // Convert JSON payload to Programme type
        Programme|error updatedProgramme = payload.cloneWithType(Programme);
        if updatedProgramme is error {
            // Send 400 Bad Request if programme data is invalid
            log:printInfo("Invalid programme data for programme code: " + programmeCode);
            return caller->respond(buildErrorResponse(400, "Invalid programme data"));
        }

        // Check if the programme code in the path matches the one in the payload
        if updatedProgramme.programmeCode != programmeCode {
            // Send 400 Bad Request if there is a programme code mismatch
            log:printInfo("Programme code mismatch: Path - " + programmeCode + ", Payload - " + updatedProgramme.programmeCode);
            return caller->respond(buildErrorResponse(400, "Programme code mismatch"));
        }

        // Update the existing programme in the array in a thread-safe manner
        lock {
            programmes[programmeIndex] = updatedProgramme;
        }

        // Respond with success message and updated programme
        json successResponse = { 
            "message": "Programme updated successfully", 
            "programme": <json> updatedProgramme 
        };
        log:printInfo("Programme updated successfully: " + programmeCode);
        return caller->respond(successResponse);
    }

    // 4. Retrieve the details of a specific programme by programme code
    resource function get [string programmeCode](http:Caller caller, http:Request req) returns error? {
        // Iterate over programmes to find the one with the given code
        foreach var programme in programmes {
            if programme.programmeCode == programmeCode {
                // Return the requested programme
                return caller->respond(programme);
            }
        }
        // Send 404 Not Found if the programme doesn't exist
        return caller->respond(buildErrorResponse(404, "Programme not found"));
    }

    // 5. Delete a programme's record by programme code
    resource function delete [string programmeCode](http:Caller caller, http:Request req) returns error? {
        // Check if the programme exists
        int programmeIndex = -1;
        foreach int i in 0 ..< programmes.length() {
            if programmes[i].programmeCode == programmeCode {
                programmeIndex = i;
                break;
            }
        }
        if programmeIndex == -1 {
            // Send 404 Not Found if the programme doesn't exist
            return caller->respond(buildErrorResponse(404, "Programme not found"));
        }

        // Remove the programme from the array in a thread-safe manner
        lock {
            programmes = array:filter(programmes, function(Programme p) returns boolean {
                return p.programmeCode != programmeCode;
            });
        }

        // Send 204 No Content after successful deletion
        http:Response res = new;
        res.statusCode = 204; // No Content
        return caller->respond(res);
    }


    // 7. Retrieve all the programmes that belong to the same faculty
    resource function get faculty/[string facultyName](http:Caller caller, http:Request req) returns error? {
        Programme[] facultyProgrammes = [];
        // Iterate over all programmes and filter by faculty name
        foreach var programme in programmes {
            if programme.faculty.toLowerAscii() == facultyName.toLowerAscii() {
                facultyProgrammes.push(programme);
            }
        }
        // Return the list of programmes in the requested faculty
        return caller->respond(facultyProgrammes);
    }
}

 // Check if a programme with the same code already exists
        foreach var existingProgramme in programmes {
            if existingProgramme.programmeCode == programme.programmeCode {
                // Send 409 Conflict if programme code is already used
                return caller->respond(buildErrorResponse(409, "Programme code already exists"));
            }
        }

-------------------------------------------------------------hgghhghg----------------------------------------------


public function checkAvailableTimeslots(string deliveryDay) returns (int[]|error) {
    // Initialize the MySQL client
    mysql:Client dbClient = check new ( 
        host = "localhost", 
        port = 3306, 
        database = "your_database", 
        user = "your_user", 
        password = "your_password"
    );

    // Query to get the occupied delivery times for the given delivery day
    sql:ParameterizedQuery selectQuery = `SELECT deliveryTime FROM shipment_requests WHERE deliveryDay = ${deliveryDay}`;

    // Execute the query
    stream<record {}, sql:Error> resultStream = dbClient->query(selectQuery);

    // Array to hold the occupied timeslots
    int[] occupiedTimeslots = [];

    // Iterate through the result stream
    error? e = resultStream.forEach(function(record {} result) {
        int deliveryTime = check result["deliveryTime"];
        occupiedTimeslots.push(deliveryTime);
    });

    // Close the result stream
    check resultStream.close();

    // Array to hold all possible timeslots (1 to 24)
    int[] allTimeslots = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];

    // Find the available timeslots by excluding the occupied ones
    int[] availableTimeslots = [];
    foreach int timeslot in allTimeslots {
        if (!occupiedTimeslots.includes(timeslot)) {
            availableTimeslots.push(timeslot);
        }
    }

    // Close the database client
    check dbClient.close();

    return availableTimeslots;
}

=========================================================================================

public function checkAvailableTimeslots(string deliveryDay, string shipmentType) returns (int[]|boolean|error) {
    // Initialize the MySQL client
    mysql:Client dbClient = check new ( 
        host = "localhost", 
        port = 3306, 
        database = "your_database", 
        user = "your_user", 
        password = "your_password"
    );

    // Query to count the number of requests with the same delivery type on the given day
    sql:ParameterizedQuery countQuery = `SELECT COUNT(*) AS requestCount FROM shipment_requests 
                                         WHERE deliveryDay = ${deliveryDay} AND shipmentType = ${shipmentType}`;

    // Execute the count query
    stream<record {}, sql:Error> countStream = dbClient->query(countQuery);

    // Variable to hold the count of requests
    int requestCount = 0;

    // Iterate through the result stream to get the count
    error? e = countStream.forEach(function(record {} result) {
        requestCount = check result["requestCount"];
    });

    // Close the count result stream
    check countStream.close();

    // If there are 6 or more requests, return false
    if (requestCount >= 6) {
        check dbClient.close();
        return false;
    }

    // Query to get the occupied delivery times for the given delivery day
    sql:ParameterizedQuery selectQuery = `SELECT deliveryTime FROM shipment_requests 
                                          WHERE deliveryDay = ${deliveryDay}`;

    // Execute the query
    stream<record {}, sql:Error> resultStream = dbClient->query(selectQuery);

    // Array to hold the occupied timeslots
    int[] occupiedTimeslots = [];

    // Iterate through the result stream
    e = resultStream.forEach(function(record {} result) {
        int deliveryTime = check result["deliveryTime"];
        occupiedTimeslots.push(deliveryTime);
    });

    // Close the result stream
    check resultStream.close();

    // Array to hold all possible timeslots (1 to 24)
    int[] allTimeslots = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];

    // Find the available timeslots by excluding the occupied ones
    int[] availableTimeslots = [];
    foreach int timeslot in allTimeslots {
        if (!occupiedTimeslots.includes(timeslot)) {
            availableTimeslots.push(timeslot);
        }
    }

    // Close the database client
    check dbClient.close();

    return availableTimeslots;
}
